# Линейный поиск

# Алгоритм линейного поиска определяется на таких структурах
# данных как массивы, списки и надстройки над ними — очередь
# и стек. Такой алгоритм является «решением в лоб» и сводится
# к перебору одного элемента за другим и операции сравнения на
# каждом. Как правило, линейный поиск применяется к
# неотсортированным структурам.
#
# Пусть на вход программы поступает массив из произвольного
# количества целых чисел и ещё одно целое число, которое будем
# проверять на вхождение в этот массив. Задача состоит в том,
# чтобы вернуть индекс первого вхождения элемента, если он
# входит в него, и False, если не входит.
def find(array_o, element_o):
    for i, a in enumerate(array_o):
        if a == element_o:
            return i
    return False


array = list(map(int, input().split()))
element = int(input())

print(find(array, element))


def count(array_a, element_e):
    counter = 0
    for a in array_a:
        if a == element_e:
            counter += 1
    return counter


# В худшем случае этот алгоритм работает за, потому что,
# если элемент не входит в массив, придётся провести сравнений.
# Все они не увенчаются успехом.
#
# Линейный алгоритм поиска может применяться для следующих целей:
#
# 1) Нахождение минимального/максимального элемента.
# 2) Поиск элемента с определённым значением.
# 3) Количество вхождений элемента в массив.
# 4) Количество элементов больше заданного.

# _______________
# ДВОИЧНЫЙ ПОИСК
# ---------------

# Алгоритм двоичного поиска является более совершенным,
# чем линейный поиск, однако он накладывает на структуру
# сильное ограничение — она должна быть отсортирована.
#
# Допустим, что у нас стоит такая же задача — найти
# индекс определённого элемента в массиве. В связи с
# тем, что алгоритм может искать только в отсортированном
# массиве, используем генератор последовательных чисел range.
# Суть двоичного поиска сводится к тому, что на каждой итерации
# размер исследуемого массива уменьшается в 2 раза.

def binary_search(array_o, element_o, left, right):
    if left > right:  # если левая граница превысила правую,
        return False  # значит, элемент отсутствует

    middle = (right + left) // 2  # находим середину
    if array_o[middle] == element_o:  # если элемент в середине
        return middle  # возвращаем этот индекс
    elif element_o < array_o[middle]:  # если элемент меньше элемента в середине
        # рекурсивно ищем в левой половине
        return binary_search(array_o, element_o, left, middle-1)
    else:  # иначе в правой
        return binary_search(array_o, element_o, middle+1, right)


element_o = int(input())
array_o = [i for i in range(1, 100)]

# запускаем алгоритм на левой и правой границе
print(binary_search(array_o, element_o, 0, 99))



























